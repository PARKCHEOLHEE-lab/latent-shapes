<!DOCTYPE html>
<html>
<head>
    <title>interpolator</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
        }

        button {
            position: absolute;
            z-index: 1000;
            padding: 10px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #ccc;
        }

        #container { 
            width: 100vw; 
            height: 100vh; 
        }

        #load_button { 
            top: 10px; 
            left: 10px; 
        }

        #reconstruct_button {
             top: 10px;
              left: 160px;
        }

        #result {
            position: absolute;
            top: 60px;
            left: 10px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border: 1px solid #ccc;
        }
        
        .loading { 
            opacity: 0.5; 
            pointer-events: none; 
        }

        .select_box {
            border: 1px solid #ccc;
            background-color: rgba(255, 255, 255, 0.2);
            position: fixed;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <button id="load_button" onclick="load_random_shape()">Load Random Shape</button>
    <button id="reconstruct_button" onclick="reconstruct()">Reconstruct Shape</button>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { TransformControls } from "three/addons/controls/TransformControls.js";
        import { SelectionBox } from 'three/addons/interactive/SelectionBox.js';
        import { SelectionHelper } from 'three/addons/interactive/SelectionHelper.js';

        let scene, camera, renderer;
        let orbit_controls, raycaster, mouse;
        let transform_controls;

        let latent_shape = [];
        let faces = [];
        let selected_object = null;
        let selected_point_index = -1;

        // create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // add grid helper
        const grid_helper = new THREE.GridHelper(20, 20);
        scene.add(grid_helper);

        // add axes helper
        const axes_helper = new THREE.AxesHelper(5);
        scene.add(axes_helper);

        // set renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("container").appendChild(renderer.domElement);

        // create camera
        camera = new THREE.PerspectiveCamera(5, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.x = 10.5;
        camera.position.y = 5.5;
        camera.position.z = -10.5;

        orbit_controls = new OrbitControls(camera, renderer.domElement);
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // gizmo
        transform_controls = new TransformControls(camera, renderer.domElement);
        transform_controls.setMode("translate");
        transform_controls.setSize(0.5);
        scene.add(transform_controls);

        const selection_box = new SelectionBox(camera, scene);
        const selection_helper = new SelectionHelper( selection_box, renderer, "select_box" );
        selection_helper.isDown = false;
        selection_helper.element.style.display = "none";

        let is_selection_mode = false;
        
        let last_camera_position = camera.position.clone();

        window.addEventListener("keydown", on_keydown);
        window.addEventListener("keyup", on_keyup);
        window.addEventListener("mousedown", on_mousedown);
        // window.addEventListener("mouseup", on_mouseup);
        window.addEventListener("click", on_click);

        function on_keydown(event) {
            if (event.key === "Shift") {
                is_selection_mode = true;
                orbit_controls.enabled = false;
                document.body.style.cursor = "crosshair";
                selection_helper.isDown = true;
                selection_helper.element.style.display = "block";
            }
        }
        
        function on_keyup(event) {
            if (event.key === "Shift") {
                is_selection_mode = false;
                orbit_controls.enabled = true;
                document.body.style.cursor = "default";
                selection_helper.isDown = false;
                selection_helper.element.style.display = "none";
            }
        }

        function on_click(event) {

            const current_camera_position = camera.position.clone()
            const has_camera_moved = (
                Math.abs(current_camera_position.x - last_camera_position.x) < 0.001 ||
                Math.abs(current_camera_position.y - last_camera_position.y) < 0.001 ||
                Math.abs(current_camera_position.z - last_camera_position.z) < 0.001
            )
            // console.log(last_camera_position)
            // console.log(current_camera_position)
            // console.log(has_camera_moved)
            
            last_camera_position = current_camera_position;
            

            if (!is_selection_mode && !has_camera_moved) {
                for (const child of scene.children) {
                    if (
                        child.name === "latent_shape"
                        && child.geometry.type === "SphereGeometry"
                    ) {
                        child.material.color.set(0x0000ff)
                    }
                }
                return
            }
        }

        function on_mousedown(event) {
            if (!is_selection_mode) {
                return
            }

            selection_box.startPoint.set(
                ( event.clientX / window.innerWidth ) * 2 - 1, 
                -( event.clientY / window.innerHeight ) * 2 + 1,
                0.5 );
        }

        // function on_mouseup(event) {
        //     is_controls_active = false;
        // }

        // window.addEventListener( "pointermove", function ( event ) {
        //     if ( event.key === "Shift" && helper.isDown ) {
        //         console.log(helper.isDown)

        //         for ( let i = 0; i < selection_box.collection.length; i ++ ) {
        //             selection_box.collection[ i ].material.emissive.set( 0x000000 );
        //         }

        //         selection_box.endPoint.set(
        //             ( event.clientX / window.innerWidth ) * 2 - 1,
        //             - ( event.clientY / window.innerHeight ) * 2 + 1,
        //             0.5 );

        //         const allSelected = selection_box.select();

        //         for ( let i = 0; i < allSelected.length; i ++ ) {

        //             allSelected[ i ].material.emissive.set( 0xffffff );

        //         }

        //     }

        // } );

        window.addEventListener( "pointerup", function ( event ) {
            if (!is_selection_mode ) {
                for (const selected of selection_box.collection) {
                    if (
                        selected.name === "latent_shape"
                        && selected.geometry.type === "SphereGeometry"
                    ) {
                        selected.material.color.set(0x0000ff)
                    }
                }
                return;
            }

            selection_box.endPoint.set(
                ( event.clientX / window.innerWidth ) * 2 - 1,
                - ( event.clientY / window.innerHeight ) * 2 + 1,
                0.5 );

            const all_selected = selection_box.select();

            for (const selected of all_selected) {
                
                if (
                    selected.name === "latent_shape"
                    && selected.geometry.type === "SphereGeometry"
                ) {
                    selected.material.color.set(0xff0000)
                }
            } 

            // for ( let i = 0; i < all_selected.length; i ++ ) {



                // all_selected[i].material.emissive.set( 0xff0000 );

            // }

        } );


        // disable orbit controls when using transform controls
        // transform_controls.addEventListener("dragging-changed", dragging_changed);

        // // update `points` when object is moved
        // transform_controls.addEventListener("objectChange", function (event) {
        //     if (selected_object && selected_point_index !== -1) {

        //         // update `points` with new position using stored index
        //         points[selected_point_index] = [
        //             selected_object.position.x,
        //             selected_object.position.y,
        //             selected_object.position.z,
        //         ];

        //         // remove existing latent shape line segments
        //         for (let child of scene.children) {
        //             if (child.name === "latent_shape" && child.type === "LineSegments") {
        //                 scene.remove(child);
        //             }
        //         }

        //         // render latent shape line segments
        //         add_line_segments_with_faces(points, faces, false);
        //     }
        // });

        // window.addEventListener("click", on_click);

        window.addEventListener("resize", on_window_resize);

        // function dragging_changed(event) {
        //     orbit_controls.enabled = !event.value;
        // }

        // function on_click(event) {
        //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        //     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        //     raycaster.setFromCamera(mouse, camera);

        //     const intersects = raycaster.intersectObjects(scene.children, true);

        //     for (let intersect of intersects) {
        //         if (
        //             intersect.object.name === "latent_shape"
        //             && intersect.object.geometry.type === "SphereGeometry"
        //         ) {
        //             if (intersect.object.material.color.getHex() === 0xff0000) {
        //                 intersect.object.material.color.set(0x0000ff);

        //                 // deselect the object
        //                 if (selected_object === intersect.object) {
        //                     transform_controls.detach();
        //                     selected_object = null;
        //                     selected_point_index = -1;
        //                 }
        //             } else {
        //                 intersect.object.material.color.set(0xff0000);

        //                 // find the index of this point in the `points`
        //                 const _selected_point_index = points.findIndex(point =>
        //                     Math.abs(point[0] - intersect.object.position.x) < 0.001 &&
        //                     Math.abs(point[1] - intersect.object.position.y) < 0.001 &&
        //                     Math.abs(point[2] - intersect.object.position.z) < 0.001
        //                 );

        //                 // select the object and attach gizmo
        //                 selected_object = intersect.object;
        //                 selected_point_index = _selected_point_index;
        //                 transform_controls.attach(selected_object);
        //                 break;
        //             }
        //         }
        //     }
        // }

        function on_window_resize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function clear_scene(mode="") {
            const children_to_remove = [];

            // clear gizmo if object is selected
            if (selected_object) {
                transform_controls.detach();
                selected_object = null;
                selected_point_index = -1;
            }

            // remove reconstructed mesh
            if (mode === "reconstruct") {
                for (let child of scene.children) {
                    if (child.name === "reconstructed_mesh" || child.name === "reconstructed_wireframe") {
                        children_to_remove.push(child);
                    }
                }
            }
            // remove latent shape
            else {
                for (let child of scene.children) {
                    if (child.name === "latent_shape" || child.name === "reconstructed_mesh" || child.name === "reconstructed_wireframe") {
                        children_to_remove.push(child);
                    }
                }

                latent_shape = [];
            }

            for (let child of children_to_remove) {
                scene.remove(child);
            }
        }

        function add_point(x, y, z) {
            const geometry = new THREE.SphereGeometry(0.015);
            const material = new THREE.MeshBasicMaterial({color: 0x0000ff});
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            sphere.name = "latent_shape";

            scene.add(sphere);
            latent_shape.push([x, y, z]);
        }

        function add_line_segments_with_faces(latent_shape, faces, y_to_z=true) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            for (let face of faces) {
                for (let i = 0; i < face.length; i++) {
                    const curr_index = face[i];
                    const next_index = face[(i + 1) % face.length];

                    const curr_vertex = latent_shape[curr_index];
                    const next_vertex = latent_shape[next_index];

                    if (y_to_z) {
                        positions.push(curr_vertex[0], curr_vertex[2], curr_vertex[1]);
                        positions.push(next_vertex[0], next_vertex[2], next_vertex[1]);
                    } else {
                        positions.push(curr_vertex[0], curr_vertex[1], curr_vertex[2]);
                        positions.push(next_vertex[0], next_vertex[1], next_vertex[2]);
                    }
                }
            }

            geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));

            const material = new THREE.LineBasicMaterial({
                color: 0x000000,
                linewidth: 1,
                transparent: true,
                opacity: 0.1
            });

            const wireframe = new THREE.LineSegments(geometry, material);
            wireframe.name = "latent_shape";
            scene.add(wireframe);

        }

        function add_reconstructed_mesh(vertices, faces) {
            const geometry = new THREE.BufferGeometry();

            const vertexArray = new Float32Array(vertices.length * 3);
            for (let i = 0; i < vertices.length; i++) {
                const vertex = vertices[i];
                vertexArray[i * 3] = vertex[0];
                vertexArray[i * 3 + 1] = vertex[2];
                vertexArray[i * 3 + 2] = vertex[1];
            }

            geometry.setAttribute("position", new THREE.BufferAttribute(vertexArray, 3));

            const indices = [];
            for (let face of faces) {
                if (face.length === 3) {
                    indices.push(face[0], face[1], face[2]);
                } else if (face.length === 4) {
                    indices.push(face[0], face[1], face[2]);
                    indices.push(face[0], face[2], face[3]);
                }
            }

            geometry.setIndex(indices);
            geometry.computeVertexNormals();


            const mesh_material = new THREE.MeshBasicMaterial(
                {
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6,
                    wireframe: false,
                    side: THREE.DoubleSide,
                }
            )
            
            const mesh_wireframe_material = new THREE.MeshBasicMaterial(
                {
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.4,
                    wireframe: true,
                    side: THREE.DoubleSide,
                }
            )

            const mesh = new THREE.Mesh(geometry, mesh_material);
            mesh.name = "reconstructed_mesh";
            scene.add(mesh);

            const wireframe = new THREE.Mesh(geometry, mesh_wireframe_material);
            wireframe.name = "reconstructed_wireframe";
            scene.add(wireframe);

        }

        function render() {
            orbit_controls.update();
            renderer.render(scene, camera);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        async function load_random_shape() {
            const load_button = document.getElementById("load_button");
            const reconstruct_button = document.getElementById("reconstruct_button");
            const container = document.getElementById("container");

            load_button.disabled = true;
            reconstruct_button.disabled = true;
            container.classList.add("loading");

            try {
                const response = await fetch("/api/latent_shapes");
                const latent_shape_data = await response.json();

                const latent_shape = latent_shape_data.latent_shape;
                faces = latent_shape_data.faces;

                // clear existing objects
                clear_scene();

                // render latent shape vertices
                for (let vertex of latent_shape) {
                    add_point(vertex[0], vertex[2], vertex[1]);
                }

                // render latent shape line segments
                add_line_segments_with_faces(latent_shape, faces);

                render();

            } catch (error) {
                console.error("Error loading random shape:", error);
                document.getElementById("result").innerHTML = error.message;
            } finally {
                load_button.disabled = false;
                reconstruct_button.disabled = false;
                container.classList.remove("loading");
            }
        }

        async function reconstruct() {
            if (latent_shape.length === 0) {
                alert("There is no latent shape to reconstruct");
                return;
            }

            const reconstruct_button = document.getElementById("reconstruct_button");
            const container = document.getElementById("container");

            reconstruct_button.disabled = true;
            container.classList.add("loading");

            try {
                const response = await fetch("/api/reconstruct", {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({latent_shapes: latent_shape})
                });

                const result_data = await response.json();

                if (response.ok && result_data.vertices && result_data.faces) {
                    clear_scene("reconstruct");
                    add_reconstructed_mesh(result_data.vertices, result_data.faces);
                } else {
                    console.error("Reconstruction failed:", result_data.message);
                    alert("Reconstruction failed: " + result_data.message);
                }

            } catch (error) {
                console.error("Error during reconstruction:", error);
                alert("Error: " + error.message);
            } finally {
                reconstruct_button.disabled = false;
                container.classList.remove("loading");
            }
        }

        // 전역 함수로 노출
        window.load_random_shape = load_random_shape;
        window.reconstruct = reconstruct;

        animate();
    </script>
</body>
</html>
