<!DOCTYPE html>
<html>
<head>
    <title>interpolator</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #sidebar {
            position: fixed;
            left: 20px;
            top: 20px;
            width: 280px;
            max-height: calc(100vh - 40px);
            background: rgba(248, 249, 250, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .control-group h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-item {
            margin-bottom: 15px;
        }

        .control-item:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            font-weight: 500;
            color: #555;
        }

        .slider-container {
            position: relative;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            appearance: none;
            margin-bottom: 8px;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider-value {
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox {
            width: 16px;
            height: 16px;
            accent-color: #007bff;
        }

        .btn {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover:not(:disabled) {
            background: #0056b3;
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .btn.secondary {
            background: #6c757d;
        }

        .btn.secondary:hover:not(:disabled) {
            background: #545b62;
        }

        .btn.primary {
            background: #007bff;
        }

        .btn.primary:hover:not(:disabled) {
            background: #0056b3;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            left: 0;
            top: 0;
        }

        .loading {
            opacity: 0.5;
            pointer-events: none;
        }

        .btn.loading {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .select_box {
            border: 1px solid #ccc;
            background-color: rgba(255, 255, 255, 0.2);
            position: fixed;
        }

        #result {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div class="control-group">
            <h3>Shape Controls</h3>
            <div class="control-item">
                <button id="load_random_shape_button" class="btn" onclick="load_random_shape()">Load Latent Shape</button>
            </div>
            <div class="control-item">
                <button id="reconstruct_button" class="btn secondary" onclick="reconstruct()">Reconstruct</button>
            </div>
        </div>

        <div class="control-group">
            <h3>Settings</h3>
            <div class="control-item">
                <label for="resolution_slider">Resolution</label>
                <div class="slider-container">
                    <input type="range" id="resolution_slider" class="slider" min="32" max="256" value="64" step="8">
                    <div class="slider-value" id="resolution_value">64</div>
                </div>
            </div>
            <div class="control-item">
                <div class="checkbox-container">
                    <input type="checkbox" id="rescale_checkbox" class="checkbox" checked>
                    <label for="rescale_checkbox">Rescale</label>
                </div>
            </div>
        </div>

        <div class="control-group">
            <h3>Instructions</h3>
            <div style="font-size: 12px; color: #666; line-height: 1.4;">
                <p><strong>Selection:</strong> Hold Shift + drag to select vertices</p>
                <p><strong>Transform:</strong> Drag the gizmo to move selected vertices</p>
                <p><strong>Clear:</strong> Press Escape to clear selection</p>
            </div>
        </div>
    </div>
    
    <div id="container"></div>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { TransformControls } from "three/addons/controls/TransformControls.js";
        import { SelectionBox } from "three/addons/interactive/SelectionBox.js";
        import { SelectionHelper } from "three/addons/interactive/SelectionHelper.js";
        import { BufferGeometryUtils } from "three/addons/utils/BufferGeometryUtils.js";

        const LATENT_SHAPE = "latent_shape"
        const LATENT_SHAPE_WIREFRAME = "latent_shape_wireframe"
        const RECONSTRUCTED_MESH = "reconstructed_mesh"
        const RECONSTRUCTED_MESH_WIREFRAME = "reconstructed_mesh_wireframe"
        const RECONSTRUCTION_MODE = "reconstruction_mode"

        const LATENT_SHAPE_SPHERE_RAD = 0.008
        const LATENT_SHAPE_SPHERE_COLOR = 0x0000ff
        const LATENT_SHAPE_SPHERE_SELECTED_COLOR = 0xff0000

        const LATENT_SHAPE_WIREFRAME_MATERIAL = new THREE.MeshBasicMaterial(
            {
                color: 0x0000ff,
                transparent: true,
                opacity: 0.1,
                wireframe: true,
                side: THREE.DoubleSide,
            }
        )

        const LATENT_SHAPE_SPHERE_MATERIAL = new THREE.MeshBasicMaterial(
            {
                color: LATENT_SHAPE_SPHERE_COLOR,
            }
        )

        const RECONSTRUCTED_MESH_WIREFRAME_MATERIAL = new THREE.MeshBasicMaterial(
            {
                color: 0x808080,
                transparent: true,
                opacity: 0.2,
                wireframe: true,
                side: THREE.DoubleSide,
            }
        )

        const RECONSTRUCTED_MESH_MATERIAL = new THREE.MeshBasicMaterial(
            {
                color: 0x808080,
                transparent: true,
                opacity: 0.05,
                wireframe: false,
                side: THREE.DoubleSide,
            }
        )

        const BOX_LINESEGMENTS_MATERIAL = new THREE.LineDashedMaterial(
            { 
                color: 0x808080,
                linewidth: 2,
                dashSize: 0.01,
                gapSize: 0.01,
            }
        );

        let latent_shape = [];
        let latent_shape_faces = [];
        let latent_shape_wireframe = new THREE.Mesh();
        
        let reconstructed = new THREE.Group();
        let first_selected_latent_shape = new THREE.Mesh();
        let selected_shape = [];
        let selected_indices = [];

        let is_mouse_down = false;
        let is_selection_mode = false;

        let box_geometry = new THREE.BoxGeometry(1, 1, 1)
        box_geometry = new THREE.EdgesGeometry(box_geometry);

        box_geometry = new THREE.LineSegments(box_geometry, BOX_LINESEGMENTS_MATERIAL);
        box_geometry.computeLineDistances();

        // create scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const grid_helper = new THREE.GridHelper(10, 10);
        const axes_helper = new THREE.AxesHelper(5);

        // set renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("container").appendChild(renderer.domElement);

        // create camera
        const camera = new THREE.PerspectiveCamera(5, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.x = 18.5;
        camera.position.y = 5.5;
        camera.position.z = -18.5;

        const orbit_controls = new OrbitControls(camera, renderer.domElement);

        // gizmo
        const transform_controls = new TransformControls(camera, renderer.domElement);
        transform_controls.setMode("translate");
        transform_controls.setSize(0.5);

        const selection_box = new SelectionBox(camera, scene);
        const selection_helper = new SelectionHelper( selection_box, renderer, "select_box" );
        selection_helper.isDown = false;
        selection_helper.element.style.display = "none";

        // scene
        // scene.add(grid_helper);
        // scene.add(axes_helper);
        scene.add(transform_controls);
        scene.add(box_geometry);

        window.load_random_shape = load_random_shape;
        window.reconstruct = reconstruct;

        // Initialize sidebar controls
        const resolution_slider = document.getElementById("resolution_slider");
        const resolution_value = document.getElementById("resolution_value");
        const rescale_checkbox = document.getElementById("rescale_checkbox");

        // Update resolution value display when slider changes
        resolution_slider.addEventListener("input", function() {
            resolution_value.textContent = this.value;
        });

        window.addEventListener("keydown", on_keydown);
        window.addEventListener("keyup", on_keyup);
        window.addEventListener("pointerdown", on_pointerdown);
        window.addEventListener("pointerup", on_pointerup);
        window.addEventListener("resize", on_window_resize);

        // eventlisteners of window
        function on_keydown(event) {
            if (event.key === "Shift" && !is_mouse_down) {
                is_selection_mode = true;
                orbit_controls.enabled = false;
                document.body.style.cursor = "crosshair";
                selection_helper.isDown = true;
                selection_helper.element.style.display = "block";
            } else if (event.key === "Escape") {
                selected_shape = [];
                selected_indices = [];
                transform_controls.detach();
                for (const vertex of latent_shape) {
                    vertex.material.color.set(LATENT_SHAPE_SPHERE_COLOR)
                }
            }
        }

        function on_keyup(event) {
            if (event.key === "Shift") {
                is_selection_mode = false;
                orbit_controls.enabled = true;
                document.body.style.cursor = "default";
                selection_helper.isDown = false;
                selection_helper.element.style.display = "none";
            }
        }

        function on_pointerdown(event) {
            is_mouse_down = true;

            if (!is_selection_mode) {
                return
            }

            selection_box.startPoint.set(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1,
                0.5 
            );
        }

        function on_pointerup(event) {
            is_mouse_down = false;

            if (!is_selection_mode ) {
                return;
            }
            
            selection_box.endPoint.set(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1,
                0.5
            );
            
            const selections = selection_box.select();

            for (const selected_index of selected_indices) {
                latent_shape[selected_index].material.color.set(LATENT_SHAPE_SPHERE_COLOR);
            }

            selected_shape = [];
            selected_indices = [];

            for (const selection of selections) {
                if (selection.name === LATENT_SHAPE) {
                    let selected_index = -1;
                    selected_shape.push(selection)
                    selection.material.color.set(LATENT_SHAPE_SPHERE_SELECTED_COLOR);
                    for (let i = 0; i < latent_shape.length; i++) {
                        const vertex = latent_shape[i];
                        if (
                            Math.abs(selection.position.x - vertex.position.x) <= 0.001
                            && Math.abs(selection.position.y - vertex.position.y) <= 0.001
                            && Math.abs(selection.position.z - vertex.position.z) <= 0.001
                        ) {
                            selected_index = i;
                            break;    
                        }
                    }

                    if (0 <= selected_index && selected_index < latent_shape.length) {
                        selected_indices.push(selected_index);
                    }
                }
            }
            
            if (selected_shape.length > 0) {
                first_selected_latent_shape = {
                    position: selected_shape[0].position.clone(),
                    relative_positions: selected_shape.map(shape => shape.position.clone())
                };
                transform_controls.attach(selected_shape[0]);
            } else {
                transform_controls.detach();
            }
        }

        function on_window_resize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // eventlisteners of transform_controls
        transform_controls.addEventListener("objectChange", on_objectchange);
        transform_controls.addEventListener("dragging-changed", on_dragging_changed);

        function on_objectchange(event) {
            if (selected_shape.length === 0 || !first_selected_latent_shape) {
                return;
            }
            
            const dx = selected_shape[0].position.x - first_selected_latent_shape.position.x;
            const dy = selected_shape[0].position.y - first_selected_latent_shape.position.y;
            const dz = selected_shape[0].position.z - first_selected_latent_shape.position.z;

            for (let i = 1; i < selected_shape.length; i++) {
                const original_pos = first_selected_latent_shape.relative_positions[i];
                selected_shape[i].position.x = original_pos.x + dx;
                selected_shape[i].position.y = original_pos.y + dy;
                selected_shape[i].position.z = original_pos.z + dz;
            }

            const latent_shape_vertices = latent_shape.map(
                child => [child.position.x, child.position.y, child.position.z]
            );

            scene.remove(latent_shape_wireframe);

            latent_shape_wireframe = create_mesh(
                latent_shape_vertices, 
                latent_shape_faces, 
                LATENT_SHAPE_WIREFRAME_MATERIAL,
            );

            scene.add(latent_shape_wireframe);
        }

        function on_dragging_changed(event) {
            orbit_controls.enabled = !event.value;
        }

        // utils
        function clear_scene(mode="") {
            if (mode === RECONSTRUCTION_MODE) {
                reconstructed.clear()
            } else {
                transform_controls.detach();
                for (const vertex of latent_shape) {
                    scene.remove(vertex)
                }
                latent_shape = [];
                selected_shape = [];
                reconstructed.clear()
                latent_shape_wireframe.geometry = new THREE.BufferGeometry();
            }
            updateReconstructButton();
        }

        function create_mesh(vertices, faces, material) {
            const geometry = new THREE.BufferGeometry();
            
            const vertices_array = new Float32Array(vertices.length * 3);
            for (let i = 0; i < vertices.length; i++) {
                const vertex = vertices[i];
                vertices_array[i * 3] = vertex[0];
                vertices_array[i * 3 + 1] = vertex[1];
                vertices_array[i * 3 + 2] = vertex[2];
            }

            geometry.setAttribute("position", new THREE.BufferAttribute(vertices_array, 3));

            const indices = [];
            for (let face of faces) {
                if (face.length === 3) {
                    indices.push(face[0], face[1], face[2]);
                } else if (face.length === 4) {
                    indices.push(face[0], face[1], face[2]);
                    indices.push(face[0], face[2], face[3]);
                }
            }

            geometry.setIndex(indices);
            
            const mesh = new THREE.Mesh(geometry, material);

            return mesh
        }

        function updateReconstructButton() {
            const reconstruct_button = document.getElementById("reconstruct_button");
            if (latent_shape.length > 0) {
                reconstruct_button.classList.remove("secondary");
                reconstruct_button.classList.add("primary");
            } else {
                reconstruct_button.classList.remove("primary");
                reconstruct_button.classList.add("secondary");
            }
        }

        async function load_random_shape() {
            const load_random_shape_button = document.getElementById("load_random_shape_button");
            const reconstruct_button = document.getElementById("reconstruct_button");
            const container = document.getElementById("container");

            load_random_shape_button.disabled = true;
            reconstruct_button.disabled = true;
            load_random_shape_button.classList.add("loading");
            reconstruct_button.classList.add("loading");

            try {
                const response = await fetch("/api/latent_shapes");
                const response_json = await response.json();

                latent_shape_faces = response_json.faces

                clear_scene();

                const latent_shape_vertices = []
                for (let vertex of response_json.latent_shape) {
                    const vertex_ordered = [vertex[0], vertex[2], vertex[1]]
                    const sphere = new THREE.Mesh(
                        new THREE.SphereGeometry(LATENT_SHAPE_SPHERE_RAD), 
                        LATENT_SHAPE_SPHERE_MATERIAL.clone()
                    );
                    
                    latent_shape_vertices.push(vertex_ordered)
                    sphere.position.set(...vertex_ordered);             
                    sphere.name = LATENT_SHAPE;

                    scene.add(sphere)
                    latent_shape.push(sphere)
                }
                
                latent_shape_wireframe = create_mesh(
                    latent_shape_vertices, 
                    latent_shape_faces, 
                    LATENT_SHAPE_WIREFRAME_MATERIAL,
                )

                latent_shape_wireframe.name = LATENT_SHAPE_WIREFRAME
                scene.add(latent_shape_wireframe)
                render();

            } catch (error) {
                console.error("Error loading random shape:", error);
                document.getElementById("result").innerHTML = error.message;
            } finally {
                load_random_shape_button.disabled = false;
                reconstruct_button.disabled = false;
                load_random_shape_button.classList.remove("loading");
                reconstruct_button.classList.remove("loading");
                updateReconstructButton();
            }
        }

        async function reconstruct() {
            if (latent_shape.length === 0) {
                alert("There is no latent shape to reconstruct");
                return;
            }

            const load_random_shape_button = document.getElementById("load_random_shape_button");
            const reconstruct_button = document.getElementById("reconstruct_button");
            const container = document.getElementById("container");
            
            // 원래 클래스 저장
            const originalClass = reconstruct_button.classList.contains("primary") ? "primary" : "secondary";
            
            // 버튼 비활성화 및 스타일 변경
            load_random_shape_button.disabled = true;
            reconstruct_button.disabled = true;
            load_random_shape_button.classList.add("loading");
            reconstruct_button.classList.add("loading");
            reconstruct_button.classList.remove(originalClass);
            reconstruct_button.classList.add("disabled");  // disabled 스타일 적용

            try {

                console.time("loading latentshape")
                const latent_shape_vertices = [];
                for (const child of latent_shape) {
                    if (child.name === LATENT_SHAPE) {
                        latent_shape_vertices.push([child.position.x, child.position.z, child.position.y])
                    }
                }
                console.timeEnd("loading latentshape")

                console.time("reconstructing with latentshape")
                
                // Get current control values
                const current_resolution = parseInt(document.getElementById("resolution_slider").value);
                const current_rescale = document.getElementById("rescale_checkbox").checked;

                const response = await fetch(
                    "/api/reconstruct", 
                    {
                        method: "POST",
                        headers: {"Content-Type": "application/json"},
                        body: JSON.stringify(
                            {
                                latent_shapes: latent_shape_vertices,
                                resolution: current_resolution,
                                rescale: current_rescale,
                            }
                        )
                    }
                );

                const result_data = await response.json();
                console.timeEnd("reconstructing with latentshape")
                const reconstructed_mesh_vertices = result_data.vertices.map(vertex => [vertex[0], vertex[2], vertex[1]])

                if (
                    response.ok 
                    && result_data.vertices 
                    && result_data.faces
                ) {
                    clear_scene(RECONSTRUCTION_MODE);
                    
                    const reconstructed_mesh = create_mesh(
                        reconstructed_mesh_vertices, 
                        result_data.faces,
                        RECONSTRUCTED_MESH_MATERIAL
                    )

                    const reconstructed_mesh_wireframe = create_mesh(
                        reconstructed_mesh_vertices, 
                        result_data.faces,
                        RECONSTRUCTED_MESH_WIREFRAME_MATERIAL
                    )

                    reconstructed.add(reconstructed_mesh)
                    reconstructed.add(reconstructed_mesh_wireframe)
                    scene.add(reconstructed);
                } else {
                    console.error("Reconstruction failed:", result_data.message);
                    alert("Reconstruction failed: " + result_data.message);
                }

            } catch (error) {
                console.error("Error during reconstruction:", error);
                alert("Error: " + error.message);
            } finally {
                // 버튼 상태 복원
                load_random_shape_button.disabled = false;
                reconstruct_button.disabled = false;
                load_random_shape_button.classList.remove("loading");
                reconstruct_button.classList.remove("loading");
                reconstruct_button.classList.remove("disabled");
                reconstruct_button.classList.add(originalClass);
            }
        }

        function render() {
            orbit_controls.update();
            renderer.render(scene, camera);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        animate();
    </script>
</body>
</html>
